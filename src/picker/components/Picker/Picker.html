<svelte:options tag={null} />
<section
  class="picker"
  aria-label={i18n.regionLabel}
  style={pickerStyle}
  bind:this={rootElement}>
  <!-- using a spacer div because this allows us to cover up the skintone picker animation -->
  <div class="pad-top"></div>
  <div class="search-row">
    <div class="search-wrapper">
      <!-- no need for aria-haspopup=listbox, it's the default for role=combobox
           https://www.w3.org/TR/2017/NOTE-wai-aria-practices-1.1-20171214/examples/combobox/aria1.1pattern/listbox-combo.html
           -->
      <input
        id="search"
        class="search"
        type="search"
        role="combobox"
        enterkeyhint="search"
        placeholder={i18n.searchLabel}
        autocapitalize="none"
        autocomplete="off"
        spellcheck="true"
        aria-expanded={!!(searchMode && currentEmojis.length)}
        aria-controls="search-results"
        aria-owns="search-results"
        aria-describedby="search-description"
        aria-autocomplete="list"
        aria-activedescendant={activeSearchItemId ? `emo-${activeSearchItemId}` : ''}
        bind:value={rawSearchText}
        on:keydown={onSearchKeydown}
      >
      <label class="sr-only" for="search">{i18n.searchLabel}</label>
      <span id="search-description" class="sr-only">{i18n.searchDescription}</span>
    </div>
    <div class="skintone-button-wrapper {skinTonePickerExpandedAfterAnimation ? 'expanded' : ''}">
      <button id="skintone-button"
              part="emoji"
              class="emoji {skinTonePickerExpanded ? 'hide-focus' : ''}"
              aria-label={skinToneButtonLabel}
              title={skinToneButtonLabel}
              aria-describedby="skintone-description"
              aria-haspopup="listbox"
              aria-expanded={skinTonePickerExpanded}
              aria-controls="skintone-list"
              on:click={onClickSkinToneButton}>
        {skinToneButtonText}
      </button>
    </div>
    <span id="skintone-description" class="sr-only">{i18n.skinToneDescription}</span>
    <div id="skintone-list"
         class="skintone-list {skinTonePickerExpanded ? '' : 'hidden no-animate'}"
         style="{skinTonePickerExpanded ? 'transform: translateY(0);' : 'transform: translateY(calc(-1 * var(--num-skintones) * var(--total-emoji-size)))'}"
         role="listbox"
         aria-label={i18n.skinTonesLabel}
         aria-activedescendant="skintone-{activeSkinTone}"
         aria-hidden={!skinTonePickerExpanded}
         on:focusout={onSkinToneOptionsFocusOut}
         on:click={onSkinToneOptionsClick}
         on:keydown={onSkinToneOptionsKeydown}
         on:keyup={onSkinToneOptionsKeyup}
         bind:this={skinToneDropdown}>
      {#each skinTones as skinTone, i (skinTone)}
        <!-- would use a button here, but iOS Safari misreports relatedTarget in that case, see issue #14 -->
        <!-- see https://stackoverflow.com/a/42764495/680742 -->
        <!-- see also https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus -->
        <div    id="skintone-{i}"
                part="emoji"
                class="emoji skintone-option cursor-pointer hide-focus {i === activeSkinTone ? 'active' : ''}"
                aria-selected={i === activeSkinTone}
                role="option"
                title={i18n.skinTones[i]}
                tabindex="-1"
                aria-label={i18n.skinTones[i]}>
          {skinTone}
        </div>
      {/each}
    </div>

  </div>
  <div class="nav"
       role="tablist"
       style="grid-template-columns: repeat({groups.length}, 1fr);"
       aria-label={i18n.categoriesLabel}
       on:keydown={onNavKeydown}>
    {#each groups as group (group.id)}
      <button role="tab"
              class="nav-button"
              aria-controls="tab-{group.id}"
              aria-label={i18n.categories[group.name]}
              aria-selected={!searchMode && currentGroup.id === group.id}
              title={i18n.categories[group.name]}
              on:click={() => onNavClick(group)}>
        <div class="emoji" part="emoji">
          {group.emoji}
        </div>
      </button>
    {/each}
  </div>
  <div class="indicator-wrapper"
       aria-hidden="true">
    <div class="indicator"
         style={indicatorStyle}
         use:calculateIndicatorWidth>
    </div>
  </div>

  <div class="message {message ? '' : 'gone'}"
       role="alert"
       aria-live="polite">
    {message}
  </div>

  <!-- tabindex is so people can scroll up and down with the keyboard -->
  <div class="tabpanel {(!loaded || message) ? 'gone': ''}"
       role={searchMode ? 'region' : 'tabpanel'}
       aria-label={searchMode ? i18n.searchResultsLabel : i18n.categories[currentGroup.name]}
       id={searchMode ? '' : `tab-${currentGroup.id}`}
       tabindex="0"
       on:click={onEmojiClick}
       bind:this={tabpanelElement}
  >
    {#each currentEmojisWithCategories as emojiWithCategory, i (emojiWithCategory.category)}
      <div
        id="menu-label-{i}"
        class="category {currentEmojisWithCategories.length > 1 ? '' : 'gone'}"
        aria-hidden="true">
        <!-- This logic is a bit complicated in order to avoid a flash of the word "Custom" while switching
             from a tabpanel with custom emoji to a regular group. I.e. we don't want it to suddenly flash
             from "Custom" to "Smileys and emoticons" when you click the second nav button. -->
        {searchMode ? i18n.searchResultsLabel : (
          emojiWithCategory.category ? emojiWithCategory.category : (
            currentEmojisWithCategories.length > 1 ? i18n.categories.custom : i18n.categories[currentGroup.name]
          )
        )}
      </div>
      <div class="emoji-menu"
           role={searchMode ? 'listbox' : 'menu'}
           aria-labelledby="menu-label-{i}"
           id={searchMode ? 'search-results' : ''}
           use:calculateEmojiGridWidth>
        {#each emojiWithCategory.emojis as emoji, i (emoji.id)}
          <button role={searchMode ? 'option' : 'menuitem'}
                  aria-selected={searchMode ? i == activeSearchItem : ''}
                  aria-label={labelWithSkin(emoji, currentSkinTone)}
                  title={emoji.title}
                  class="emoji {searchMode && i === activeSearchItem ? 'active' : ''}"
                  id="emo-{emoji.id}"
                  part="emoji">
            {#if emoji.unicode}
              {unicodeWithSkin(emoji, currentSkinTone)}
            {:else}
              <div class="custom-emoji"
                   style="background-image: url({emoji.url});"
              />
            {/if}
          </button>
        {/each}
      </div>
    {/each}
  </div>
  <div class="favorites emoji-menu {message ? 'gone': ''}"
       role="menu"
       aria-label={i18n.favoritesLabel}
       style="padding-right: {scrollbarWidth}px;"
       on:click={onEmojiClick}
       data-testid="favorites">
    <!-- TODO: the reason so much of this emoji logic is duplicated is because it would be wasteful
         or incorrect to extract this logic into a custom Svelte component, because in customElements
         mode, Svelte will render _all_ components as custom elements. Ideally we just want one
         custom element wrapper around the outer component -->
    {#each currentFavorites as emoji, i (emoji.id)}
      <button role="menuitem"
              aria-label={labelWithSkin(emoji, currentSkinTone)}
              title={emoji.title}
              class="emoji"
              part="emoji"
              id="fav-{emoji.id}">
        {#if emoji.unicode}
          {unicodeWithSkin(emoji, currentSkinTone)}
        {:else}
          <img class="custom-emoji"
               src={emoji.url}
               loading="lazy"
               alt=""
          />
        {/if}
      </button>
    {/each}
  </div>
  <div aria-hidden="true" class="hidden abs-pos">
    <button tabindex="-1" class="emoji baseline-emoji" part="emoji" bind:this={baselineEmoji}>ðŸ˜€</button>
  </div>
</section>